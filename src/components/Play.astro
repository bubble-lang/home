---
//@ts-nocheck
interface Props {
  initialCode?: string;
  active?: boolean;
}

const { initialCode = "", active = false } = Astro.props;
---

<bubble-repl-tutorial data-initial-code={initialCode} data-active={active.toString()}>
  <div class="my-4 relative">
    <div class="mb-4">
      <slot name="instructions"></slot>
    </div>
    <div class="mb-4">
      <slot name="example"></slot>
    </div>
    <div class="border md:min-w-[500px] rounded-md p-4 relative">
      <div class="error-container mb-4 text-red-500" style="display: none;"></div>
      <div class="terminal-container h-0 overflow-hidden transition-all duration-500 ease-in-out mb-4">
        <div class="terminal font-mono text-lg"></div>
      </div>
      <div class="input-container w-full py-4 border-t" style="display: none;">
        <div class="input-button-container flex w-full">
          <div class="input-wrapper w-full">
            <input
              type="text"
              class="input w-full px-4 py-2 rounded-l-xl border-4 border-r-0 border-blue-50 text-blue-700 focus:outline-none focus:ring-1 ring-inset focus:ring-blue-200 font-mono"
              placeholder="Type here and press enter."
            />
            <span class="retro-cursor"></span>
          </div>
          <button
            class="run-button px-4 rounded-r-xl border-4 border-blue-50 bg-yellow-300 text-black hover:bg-yellow-400 focus:outline-none"
          >
            Run
          </button>
        </div>
      </div>
    </div>
    <div class="mt-4">
      <div class="solution-content mt-2" style="display: none;">
        <slot name="solution"></slot>
      </div>
    </div>
  </div>
</bubble-repl-tutorial>

<script>
// @ts-nocheck
  class BubbleREPLTutorial extends HTMLElement {
    constructor() {
      super();
      this.bubbleInterpreter = null;
      this.isREPLReady = false;
      this.isFirstRun = true;
      this.isWaitingForInput = false;
      this.inputResolve = null;
      this.inputValue = null;
      this.inputBuffer = '';
      this.isInBlock = false;
      this.blockType = null;
    }

    connectedCallback() {
      this.initialCode = this.getAttribute('data-initial-code') || '';
      this.active = this.getAttribute('data-active') === 'true';
      this.terminal = this.querySelector('.terminal');
      this.errorContainer = this.querySelector('.error-container');
      this.terminalContainer = this.querySelector('.terminal-container');
      this.inputContainer = this.querySelector('.input-container');
      this.input = this.querySelector('.input');
      this.runButton = this.querySelector('.run-button');
      this.solutionToggle = this.querySelector('.solution-toggle');
      this.solutionContent = this.querySelector('.solution-content');
      this.retroCursor = this.querySelector('.retro-cursor');

      document.addEventListener('wasm-environment-ready', () => this.initializeWASMInstance());

      this.input.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.handleEnter();
        }
      });

      this.input.addEventListener("input", () => this.updateCursorPosition());

      this.runButton.addEventListener("click", () => this.handleRunButton());

      if (this.solutionToggle) {
        this.solutionToggle.addEventListener("click", () => this.toggleSolution());
      }

      if (this.active) {
        this.input.focus();
      }
    }

    async initializeWASMInstance() {
      try {
        const factory = document.querySelector('wasm-initializer-factory');
        if (!factory) {
          throw new Error("WASM Initializer Factory not found");
        }
        this.bubbleInterpreter = await factory.createWASMInstance();
        this.isREPLReady = true;
        this.inputContainer.style.display = "block";
        this.input.value = this.initialCode;
        if (this.active) {
          this.input.focus();
        }
        this.updateCursorPosition();

        this.bubbleInterpreter.setOutputCallback((text) => {
          this.handleOutput(text);
        });

        if (typeof this.bubbleInterpreter.overrideInput === 'function') {
          this.bubbleInterpreter.overrideInput((message) => {
            return this.handleInput(message);
          });
        }
      } catch (error) {
        console.error("Error initializing WASM instance:", error);
        this.showError(`Failed to initialize REPL: ${error.message}`);
      }
    }

    handleRunButton() {
      if (this.isInBlock) {
        this.inputBuffer += this.input.value + '\n';
        this.appendToTerminal('> ' + this.input.value);
        this.input.value = '  '; // Add indentation
      } else {
        this.runCode(this.input.value);
      }
    }

    handleEnter() {
      const currentLine = this.input.value.trim();

      if (this.isWaitingForInput) {
        this.submitInput();
      } else if (this.isInBlock || this.isBlockStart(currentLine)) {
        this.isInBlock = true;
        this.inputBuffer += this.input.value + '\n';
        this.appendToTerminal('> ' + this.input.value);
        this.input.value = '  '; // Add indentation
      } else {
        this.runCode(this.input.value);
      }

      if (this.isBlockEnd(currentLine)) {
        this.isInBlock = false;
        this.runCode(this.inputBuffer);
        this.inputBuffer = '';
        this.blockType = null;
      }

      this.updateCursorPosition();
    }

    isBlockStart(line) {
      if (/^if\b/.test(line)) {
        this.blockType = 'if';
        return true;
      } else if (/^repeat\b/.test(line)) {
        this.blockType = 'repeat';
        return true;
      } else if (/^while\b/.test(line)) {
        this.blockType = 'while';
        return true;
      }
      return false;
    }

    isBlockEnd(line) {
      switch (this.blockType) {
        case 'if':
          return /^end\s+if\b/.test(line);
        case 'repeat':
          return /^end\s+repeat\b/.test(line);
        case 'while':
          return /^end\s+while\b/.test(line);
        default:
          return false;
      }
    }

    async runCode(code) {
      code = code.trim();
      code = code.replace(/[“”]/g, '"').replace(/[‘’]/g, "'");

      if (!this.isREPLReady) {
        this.appendToTerminal("REPL not loaded yet. Please wait...");
      } else if (code !== "") {
        if (this.isFirstRun) {
          this.revealTerminal();
          this.isFirstRun = false;
        }

        const codeLines = code.split('\n');
        codeLines.forEach(line => {
          this.appendToTerminal('> ' + line.trim());
        });

        try {
          if ((code.startsWith("set ") || code.includes(" to ") || code.includes(" = ")) && code.includes("input")) {
            let varName, inputPrompt;
            if (code.includes(" = ")) {
              [varName, inputPrompt] = code.split(" = ");
            } else {
              [varName, inputPrompt] = code.split(" to ");
              varName = varName.replace("set ", "");
            }
            varName = varName.trim();
            inputPrompt = inputPrompt.replace("input", "").trim().replace(/^"/, '').replace(/"$/, '');

            this.clearInputAndResetCursor();
            this.inputValue = await this.handleInput(inputPrompt);
            const result = await this.bubbleInterpreter.runBubble(`set ${varName} to "${this.inputValue}"`);
            if (result !== undefined && result !== null && result !== "") {
              this.handleOutput(result);
            }
          } else {
            const result = await this.bubbleInterpreter.runBubble(code);
            if (result !== undefined && result !== null) {
              if (typeof result === 'object') {
                this.handleOutput(JSON.stringify(result));
              } else {
                this.handleOutput(result.toString());
              }
            }
          }
        } catch (error) {
          console.error("Error running code:", error);
          this.handleOutput("Error: " + error.message);
        }
      }

      if (!this.isInBlock && !this.isWaitingForInput) {
        this.clearInputAndResetCursor();
      }
    }

    appendToTerminal(text) {
      const newElement = document.createElement("div");
      newElement.textContent = text;
      if (text.startsWith('>')) {
        newElement.style.color = 'blue';
      }
      this.terminal.appendChild(newElement);
      this.terminalContainer.scrollTop = this.terminalContainer.scrollHeight;
    }

    handleOutput(text) {
      text = text.trim();
      if (text !== "") {
        this.appendToTerminal(text);
      }
    }


    handleInput(message) {
      return new Promise((resolve) => {
        this.isWaitingForInput = true;
        this.inputResolve = resolve;
        this.input.placeholder = message || "Enter input...";
        this.input.focus();
        this.runButton.textContent = "Submit";
        this.appendToTerminal(message || "Enter input:");
      }).then((userInput) => {
        this.inputValue = userInput.replace(/[""]/g, '"').replace(/['']/g, "'");
        return this.inputValue;
      });
    }


    submitInput() {
          const userInput = this.input.value;
          this.appendToTerminal(`> ${userInput}`);
          this.inputValue = userInput;
          this.input.value = "";
          this.input.placeholder = "Type your code here and press Enter to run";
          this.runButton.textContent = "Run";
          this.isWaitingForInput = false;
          if (this.inputResolve) {
            this.inputResolve(userInput);
            this.inputResolve = null;
          }
        }

    clearInputAndResetCursor() {
      this.input.value = '';
      this.updateCursorPosition();
      this.input.focus();
    }

    revealTerminal() {
      this.terminalContainer.style.height = '144px';
      setTimeout(() => {
        this.terminalContainer.style.overflowY = 'auto';
      }, 500);
    }

    toggleSolution() {
      if (this.solutionContent.style.display === "none") {
        this.solutionContent.style.display = "block";
        this.solutionToggle.textContent = "Hide Solution";
      } else {
        this.solutionContent.style.display = "none";
        this.solutionToggle.textContent = "Show Solution";
      }
    }

    updateCursorPosition() {
      const inputRect = this.input.getBoundingClientRect();
      const cursorPosition = this.input.selectionStart;
      const textWidth = this.getTextWidth(this.input.value.substring(0, cursorPosition));
      const maxWidth = inputRect.width - 40;
      const clampedLeft = Math.min(textWidth, maxWidth);
      this.retroCursor.style.left = `${clampedLeft + 22}px`;

      if (textWidth > maxWidth) {
        this.input.scrollLeft = textWidth - maxWidth;
      } else {
        this.input.scrollLeft = 0;
      }
    }

    getTextWidth(text) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      context.font = getComputedStyle(this.input).font;
      return context.measureText(text).width;
    }

    showError(message) {
      if (this.errorContainer) {
        this.errorContainer.style.display = 'block';
        this.errorContainer.textContent = message;
      }
    }
  }

  if (!customElements.get('bubble-repl-tutorial')) {
    customElements.define('bubble-repl-tutorial', BubbleREPLTutorial);
  }
</script>
